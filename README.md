# Mahjong Check Win

中文版本解释

### 数据表示

对于每一张牌的表示：
``` py
[
    ["1m", "2m", "3m", "4m", "5m", "6m", "7m", "8m", "9m"], # 万牌
    ["1s", "2s", "3s", "4s", "5s", "6s", "7s", "8s", "9s"], # 条/索牌
    ["1p", "2p", "3p", "4p", "5p", "6p", "7p", "8p", "9p"], # 饼牌
    ["do", "na", "xi", "be", "zh", "fa", "ba"], # 字牌 东南西北中发白 (其实字牌顺序对于算法影响不大)
]
```


创建一个`counters`，一一对应上面每一种类型的牌在手牌中出现的次数。

```
例：1m 2m 3m 3s 4s 5s 1p 1p 5p 6p 7p fa fa fa
```

例如，以上这一副这样的牌应该被转换为一下的格式输入：

``` py
counters = [
    [1, 1, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 1, 1, 0, 0, 0, 0],
    [2, 0, 0, 0, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 3, 0],
]
```

### 面子手 分类讨论

面子手的结构可以理解为4个面子加上1个雀头（一个对子）。而面子可以是顺子（三张数字连续的牌）或者是刻子（三张一样的牌）。因此，面子手中，每一张牌肯定只能是一下组合中的一种：
1. 这个牌是一个顺子的一部分
2. 这个牌是一个刻子的一部分
3. 这个牌是一个对子的一部分

counters表中每一个非0的牌，必须是上面三种可能中的一种。将counters拆分成为4个独立的列表，命名为counter。根据上面的counters例子,万牌的counter应该是：
``` py
counter = [1, 1, 1, 0, 0, 0, 0, 0, 0]
```

从左往右遍历counter，找到第一个非0的值：
- 如果值为1，这张牌**一定**是1个顺子的第一张牌。
- 如果值为2，这张牌**可能**是2个一模一样的顺子的第一张牌，或者是1个对子。
- 如果值为3，这张牌**可能**是3个一模一样的顺子的第一张牌，或者是1个顺子的第一张牌加上1个对子，或者是1个刻子。
- 如果值为4，这张牌**可能**是4个一模一样的顺子的第一张牌，或者是2个一模一样的顺子的第一张牌加上一个对子，或者是1个顺子的第一张牌加上1个刻子。

如果第一个非0值不能满足上面的一个条件，这一副手牌**一定**没有胡。

同时，一些牌是不能考虑带有顺子的组合（例如：字牌）；一些牌不能考虑对子的组合（例如：这幅手牌已经在之前有了一个对子了）。

在考虑多种组合的可能时（例如值为2，3，4的情况），递归将会使用，依次尝试每一种组合。

### 面子手 检测组合

将以上的每一个组合总结成为一个规则（rule）。rule是一个长度为3的tuple，分别记录所需要的（顺子数量，对子数量，刻子数量）。所有的规则总结是这个样子的：
``` py
rules = {
    1: [(1, 0, 0)],
    2: [(2, 0, 0), (0, 1, 0)],
    3: [(3, 0, 0), (1, 1, 0), (0, 0, 1)],
    4: [(4, 0, 0), (2, 1, 0), (1, 0, 1)],
}
```
每一个带有顺子的组合需要满足以下条件才可以算成功匹配：
- 当前counter不是字牌counter。
- 当前的index小于等于6。（顺子会往后延续两位）
- 后面的两位的值必须大于等于顺子的数量。

每一个带有对子的组合需要满足以下条件才可以算成功匹配：
- 当前的手牌没有成功匹配过对子。

每一个带有刻子的组合可以直接算成功匹配：

每次成功匹配后，创建一个深复制。并且，在counter中减去当前匹配到的组合中所需要的牌。

递归的出口：如果一个counter的值全是0，这一个counter的检测将会传回真(True)。

### 对子手 13幺手 概要
除了普通的面子手胡牌，7对子和13幺也是两种另外的胡牌方式。

日麻中，7对子的胡牌不能包含重复的对子，其他麻将规则有的允许重复的对子。

十三幺指的是包含以下每一种牌至少一种（其中一种需要两张，其余都是一张）：
```
1m 9m 1s 9s 1p 9p do na xi be zh fa ba
```
